{"version":3,"sources":["component/Board.jsx","lib/utilis.js","App.js","index.js"],"names":["LinkedListNode","value","this","next","LinkedList","node","head","tail","Direction","getStartingSnakeLLValue","board","rowSize","length","colSize","startingRow","Math","round","startingCol","row","col","cell","createBoard","BOARD_SIZE","counter","currentRow","push","getCoordsInDirection","coords","direction","isOutOfBounds","getDirectionFromKey","key","getNextNodeDirection","currentDirection","currentCol","nextRow","nextCol","getGrowthNodeCoords","snakeTail","tailNextNodeDirection","growthDirection","getOppositeDirection","currentTailCoords","getCellClassName","cellValue","foodCell","foodShouldReverseDirection","snakeCells","className","has","Board","useState","score","setScore","snake","setSnake","Set","setSnakeCells","setFoodCell","setDirection","setFoodShouldReverseDirection","useEffect","window","addEventListener","e","handleKeydown","callback","delay","savedCallback","useRef","current","id","setInterval","clearInterval","useInterval","moveSnake","newDirection","size","currentHeadCoords","nextHeadCoords","handleGameOver","nextHeadCell","newHead","currentHead","newSnakeCells","delete","add","growSnake","reverseSnake","handleFoodConsumption","growthNodeCoords","newTailCell","newTail","currentTail","previousNode","currentNode","nextNode","reverseLinkedList","snakeHead","nextFoodCell","min","max","floor","random","nextFoodShouldReverseDirection","snakeLLStartingValue","map","rowIdx","cellIdx","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6ccb795b.chunk.js","sourcesContent":["import React, {useEffect, useState} from 'react';\r\nimport {randomIntFromInterval,\r\n  reverseLinkedList,\r\n  useInterval} from '../lib/utilis.js';\r\n\r\nimport './Board.css';\r\n\r\n\r\n\r\nclass LinkedListNode {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nclass LinkedList {\r\n  constructor(value) {\r\n    const node = new LinkedListNode(value);\r\n    this.head = node;\r\n    this.tail = node;\r\n  }\r\n}\r\n\r\nconst Direction = {\r\n  UP: 'UP',\r\n  RIGHT: 'RIGHT',\r\n  DOWN: 'DOWN',\r\n  LEFT: 'LEFT',\r\n};\r\n\r\nconst BOARD_SIZE = 15;\r\nconst PROBABILITY_OF_DIRECTION_REVERSAL_FOOD = 0.3;\r\n\r\nconst getStartingSnakeLLValue = board => {\r\n  const rowSize = board.length;\r\n  const colSize = board[0].length;\r\n  const startingRow = Math.round(rowSize / 3);\r\n  const startingCol = Math.round(colSize / 3);\r\n  const startingCell = board[startingRow][startingCol];\r\n  return {\r\n    row: startingRow,\r\n    col: startingCol,\r\n    cell: startingCell,\r\n  };\r\n};\r\n\r\nconst Board = () => {\r\n  const [score, setScore] = useState(0);\r\n  const[level,setLevel]=useState({score})\r\n  const [board, setBoard] = useState(createBoard(BOARD_SIZE));\r\n  const [snake, setSnake] = useState(\r\n    new LinkedList(getStartingSnakeLLValue(board)),\r\n  );\r\n  const [snakeCells, setSnakeCells] = useState(\r\n    new Set([snake.head.value.cell]),\r\n  );\r\n  \r\n  const [foodCell, setFoodCell] = useState(snake.head.value.cell + 5);\r\n  const [direction, setDirection] = useState(Direction.RIGHT);\r\n  const [foodShouldReverseDirection, setFoodShouldReverseDirection] = useState(\r\n    false,\r\n  );\r\n\r\n  useEffect(() => {\r\n    window.addEventListener('keydown', e => {\r\n      handleKeydown(e);\r\n    });\r\n  }, []);\r\n  useInterval(() => {\r\n    moveSnake();\r\n  }, 200);\r\n\r\n  const handleKeydown = e => {\r\n    const newDirection = getDirectionFromKey(e.key);\r\n    const isValidDirection = newDirection !== '';\r\n    if (!isValidDirection) return;\r\n    const snakeWillRunIntoItself =\r\n      getOppositeDirection(newDirection) === direction && snakeCells.size > 1;\r\n    \r\n    if (snakeWillRunIntoItself) return;\r\n    setDirection(newDirection);\r\n  };\r\n\r\n  const moveSnake = () => {\r\n    const currentHeadCoords = {\r\n      row: snake.head.value.row,\r\n      col: snake.head.value.col,\r\n    };\r\n\r\n    const nextHeadCoords = getCoordsInDirection(currentHeadCoords, direction);\r\n    if (isOutOfBounds(nextHeadCoords, board)) {\r\n      handleGameOver();\r\n      return;\r\n    }\r\n    const nextHeadCell = board[nextHeadCoords.row][nextHeadCoords.col];\r\n    if (snakeCells.has(nextHeadCell)) {\r\n      handleGameOver();\r\n      return;\r\n    }\r\n\r\n    const newHead = new LinkedListNode({\r\n      row: nextHeadCoords.row,\r\n      col: nextHeadCoords.col,\r\n      cell: nextHeadCell,\r\n    });\r\n    const currentHead = snake.head;\r\n    snake.head = newHead;\r\n    currentHead.next = newHead;\r\n\r\n    const newSnakeCells = new Set(snakeCells);\r\n    newSnakeCells.delete(snake.tail.value.cell);\r\n    newSnakeCells.add(nextHeadCell);\r\n\r\n    snake.tail = snake.tail.next;\r\n    if (snake.tail === null) snake.tail = snake.head;\r\n\r\n    const foodConsumed = nextHeadCell === foodCell;\r\n    if (foodConsumed) {\r\n      // This function mutates newSnakeCells.\r\n      growSnake(newSnakeCells);\r\n      if (foodShouldReverseDirection) reverseSnake();\r\n      handleFoodConsumption(newSnakeCells);\r\n    }\r\n\r\n    setSnakeCells(newSnakeCells);\r\n  };\r\n\r\n  // This function mutates newSnakeCells.\r\n  const growSnake = newSnakeCells => {\r\n    const growthNodeCoords = getGrowthNodeCoords(snake.tail, direction);\r\n    if (isOutOfBounds(growthNodeCoords, board)) {\r\n      // Snake is positioned such that it can't grow; don't do anything.\r\n      return;\r\n    }\r\n    const newTailCell = board[growthNodeCoords.row][growthNodeCoords.col];\r\n    const newTail = new LinkedListNode({\r\n      row: growthNodeCoords.row,\r\n      col: growthNodeCoords.col,\r\n      cell: newTailCell,\r\n    });\r\n    const currentTail = snake.tail;\r\n    snake.tail = newTail;\r\n    snake.tail.next = currentTail;\r\n\r\n    newSnakeCells.add(newTailCell);\r\n  };\r\n\r\n  const reverseSnake = () => {\r\n    const tailNextNodeDirection = getNextNodeDirection(snake.tail, direction);\r\n    const newDirection = getOppositeDirection(tailNextNodeDirection);\r\n    setDirection(newDirection);\r\n\r\n    // The tail of the snake is really the head of the linked list, which\r\n    // is why we have to pass the snake's tail to `reverseLinkedList`.\r\n    reverseLinkedList(snake.tail);\r\n    const snakeHead = snake.head;\r\n    snake.head = snake.tail;\r\n    snake.tail = snakeHead;\r\n  };\r\n\r\n  const handleFoodConsumption = newSnakeCells => {\r\n    const maxPossibleCellValue = BOARD_SIZE * BOARD_SIZE;\r\n    let nextFoodCell;\r\n    \r\n    while (true) {\r\n      nextFoodCell = randomIntFromInterval(1, maxPossibleCellValue);\r\n      if (newSnakeCells.has(nextFoodCell) || foodCell === nextFoodCell)\r\n        continue;\r\n      break;\r\n    }\r\n\r\n    const nextFoodShouldReverseDirection =\r\n      Math.random() < PROBABILITY_OF_DIRECTION_REVERSAL_FOOD;\r\n\r\n    setFoodCell(nextFoodCell);\r\n    setFoodShouldReverseDirection(nextFoodShouldReverseDirection);\r\n    setScore(score + 1);\r\n  };\r\n\r\n  const handleGameOver = () => {\r\n    setScore(0);\r\n    const snakeLLStartingValue = getStartingSnakeLLValue(board);\r\n    setSnake(new LinkedList(snakeLLStartingValue));\r\n    setFoodCell(snakeLLStartingValue.cell + 5);\r\n    setSnakeCells(new Set([snakeLLStartingValue.cell]));\r\n    setDirection(Direction.RIGHT);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <h1>Score: {score}</h1>\r\n      <div className=\"board\">\r\n        {board.map((row, rowIdx) => (\r\n          <div key={rowIdx} className=\"row\">\r\n            {row.map((cellValue, cellIdx) => {\r\n              const className = getCellClassName(\r\n                cellValue,\r\n                foodCell,\r\n                foodShouldReverseDirection,\r\n                snakeCells,\r\n              );\r\n              return <div key={cellIdx} className={className}></div>;\r\n            })}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nconst createBoard = BOARD_SIZE => {\r\n  let counter = 1;\r\n  const board = [];\r\n  for (let row = 0; row < BOARD_SIZE; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < BOARD_SIZE; col++) {\r\n      currentRow.push(counter++);\r\n    }\r\n    board.push(currentRow);\r\n  }\r\n  return board;\r\n};\r\n\r\nconst getCoordsInDirection = (coords, direction) => {\r\n  if (direction === Direction.UP) {\r\n    return {\r\n      row: coords.row - 1,\r\n      col: coords.col,\r\n    };\r\n  }\r\n  if (direction === Direction.RIGHT) {\r\n    return {\r\n      row: coords.row,\r\n      col: coords.col + 1,\r\n    };\r\n  }\r\n  if (direction === Direction.DOWN) {\r\n    return {\r\n      row: coords.row + 1,\r\n      col: coords.col,\r\n    };\r\n  }\r\n  if (direction === Direction.LEFT) {\r\n    return {\r\n      row: coords.row,\r\n      col: coords.col - 1,\r\n    };\r\n  }\r\n};\r\n\r\nconst isOutOfBounds = (coords, board) => {\r\n  const {row, col} = coords;\r\n  if (row < 0 || col < 0) return true;\r\n  if (row >= board.length || col >= board[0].length) return true;\r\n  return false;\r\n};\r\n\r\nconst getDirectionFromKey = key => {\r\n  if (key === 'ArrowUp') return Direction.UP;\r\n  if (key === 'ArrowRight') return Direction.RIGHT;\r\n  if (key === 'ArrowDown') return Direction.DOWN;\r\n  if (key === 'ArrowLeft') return Direction.LEFT;\r\n  return '';\r\n};\r\n\r\nconst getNextNodeDirection = (node, currentDirection) => {\r\n  if (node.next === null) return currentDirection;\r\n  const {row: currentRow, col: currentCol} = node.value;\r\n  const {row: nextRow, col: nextCol} = node.next.value;\r\n  if (nextRow === currentRow && nextCol === currentCol + 1) {\r\n    return Direction.RIGHT;\r\n  }\r\n  if (nextRow === currentRow && nextCol === currentCol - 1) {\r\n    return Direction.LEFT;\r\n  }\r\n  if (nextCol === currentCol && nextRow === currentRow + 1) {\r\n    return Direction.DOWN;\r\n  }\r\n  if (nextCol === currentCol && nextRow === currentRow - 1) {\r\n    return Direction.UP;\r\n  }\r\n  return '';\r\n};\r\n\r\nconst getGrowthNodeCoords = (snakeTail, currentDirection) => {\r\n  const tailNextNodeDirection = getNextNodeDirection(\r\n    snakeTail,\r\n    currentDirection,\r\n  );\r\n  const growthDirection = getOppositeDirection(tailNextNodeDirection);\r\n  const currentTailCoords = {\r\n    row: snakeTail.value.row,\r\n    col: snakeTail.value.col,\r\n  };\r\n  const growthNodeCoords = getCoordsInDirection(\r\n    currentTailCoords,\r\n    growthDirection,\r\n  );\r\n  return growthNodeCoords;\r\n};\r\n\r\nconst getOppositeDirection = direction => {\r\n  if (direction === Direction.UP) return Direction.DOWN;\r\n  if (direction === Direction.RIGHT) return Direction.LEFT;\r\n  if (direction === Direction.DOWN) return Direction.UP;\r\n  if (direction === Direction.LEFT) return Direction.RIGHT;\r\n};\r\n\r\nconst getCellClassName = (\r\n  cellValue,\r\n  foodCell,\r\n  foodShouldReverseDirection,\r\n  snakeCells,\r\n) => {\r\n  let className = 'cell';\r\n  if (cellValue === foodCell) {\r\n    if (foodShouldReverseDirection) {\r\n      className = 'cell cell-purple';\r\n    } else {\r\n      className = 'cell cell-red';\r\n    }\r\n  }\r\n  if (snakeCells.has(cellValue)) className = 'cell cell-green';\r\n\r\n  return className;\r\n};\r\n\r\nexport default Board;\r\n","import { useEffect, useRef } from \"react\";\r\n\r\n// Copied from https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\r\nexport function randomIntFromInterval(min, max) {\r\n  // min and max included\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\n// Copied from https://overreacted.io/making-setinterval-declarative-with-react-hooks/\r\nexport function useInterval(callback, delay) {\r\n  const savedCallback = useRef();\r\n\r\n  // Remember the latest callback.\r\n  useEffect(() => {\r\n    savedCallback.current = callback;\r\n  }, [callback]);\r\n\r\n  // Set up the interval.\r\n  useEffect(() => {\r\n    function tick() {\r\n      savedCallback.current();\r\n    }\r\n    if (delay !== null) {\r\n      let id = setInterval(tick, delay);\r\n      return () => clearInterval(id);\r\n    }\r\n  }, [delay]);\r\n}\r\n\r\nexport function reverseLinkedList(head) {\r\n  let previousNode = null;\r\n  let currentNode = head;\r\n  while (currentNode !== null) {\r\n    const nextNode = currentNode.next;\r\n    currentNode.next = previousNode;\r\n    previousNode = currentNode;\r\n    currentNode = nextNode;\r\n  }\r\n  return previousNode;\r\n}\r\n","import \"./App.css\";\nimport Board from \"./component/Board.jsx\";\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <Board></Board>\n    </div>\n  );\n};\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\"),\n);\n"],"sourceRoot":""}